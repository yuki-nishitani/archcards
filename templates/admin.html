<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>archcards admin (kindai)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 0; background:#fafafa; }
    .wrap { max-width: 720px; margin: 0 auto; padding: 16px; }

    .card{
      background:#fff; border:1px solid #ddd; border-radius:14px;
      padding:12px; overflow:hidden; user-select:none;
    }
    .info{ padding:12px; border-radius:10px; background:#f2f4f7; }
    .row { margin: 6px 0; line-height: 1.35; }
    .label { color:#555; font-size: 13px;font-weight: 600; margin-right: 6px; }
    .hint { color:#666; font-size: 13px; margin-top: 10px; }

    .topbar{
      display:flex; justify-content:space-between; align-items:center;
      gap:10px; margin-bottom: 10px;
    }
    .modebtn{
      padding: 8px 10px; border:1px solid #ddd; border-radius:12px;
      background:#fff;  font-weight: 700; cursor:pointer; user-select:none; font-size:15px;
      text-decoration:none; color:#111;
    }
    .modebtn:active{ transform: translateY(1px); }

    .hidden{ display:none; }
    .status{ font-size:13px; color:#666; }
    .ok{ color:#0a7; }
    .err{ color:#c00; }

    .search{
      width:100%; font-size:16px; padding:10px; box-sizing:border-box;
      border:1px solid #ddd; border-radius:12px; background:#fff;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 8px;
    }
    .mini{
      background:#fff; border:1px solid #ddd; border-radius:10px;
      padding:8px; cursor:pointer;
    }
    .mini:active{ transform: translateY(1px); }
    .mini .thumbimg{
      width:100%; height:80px; object-fit:cover;
      border-radius:6px; display:block; background:#fff;
    }
    .miniTitle{ font-weight:800; margin-top:6px; line-height:1.25; font-size:12px; }
    .miniMeta{ color:#666; font-size:11px; margin-top:3px; }

    .add-card{
      display:flex; align-items:center; justify-content:center;
      height: 120px; border: 2px dashed #ccc; border-radius: 10px;
      color:#666; font-weight: 900; background:#fff;
    }

    input.text{ width: 100%; box-sizing: border-box; font-size: 15px; padding: 7px;
      border: 1px solid #ddd; border-radius: 6px; background: #fff; }

    textarea.memo{ width:100%; box-sizing:border-box; font-size:15px; padding:7px;
      border:1px solid #ddd; border-radius:6px; background:#fff;
      min-height: 120px; resize: vertical; }

    .nav{ margin-top: 12px; display:flex; gap:10px; }
    .navbtn{  flex:1 1 0; padding:8px 10px; color: #333; border:1px solid #ddd;
      border-radius:8px; background:#f8f8f8;  text-align:center; font-weight: 700;
      cursor:pointer; user-select:none; }
    .navbtn:active{ transform: translateY(1px); }
    .navbtn[disabled]{ opacity:0.45; cursor:not-allowed; }

    .image-block{ margin-top: 16px; padding-top: 12px;
      border-top: 1px solid #e0e0e0; }

    .image-head{ font-weight: 600; font-size: 13px; color:#555; }
    .image-head input[type="file"]{ display:block; width:100%; margin: 8px 0 8px; }
    .thumb img{ width:100%; height:auto; max-height:40vh; object-fit:contain;
      border-radius: 8px; background:#fff; display:block;
      border:1px solid #eee; }

    .idRow{ display:flex; gap:8px; align-items:center; }

    .idRow .text{ flex: 1 1 auto; }

    .smallBtn{ padding: 7px; border:1px solid #ddd; border-radius:8px;
      background:#fff; font-weight:600;font-size: 14px; cursor:pointer;
      white-space: nowrap;   /* 「ID確定」を改行させない */
      flex: 0 0 auto;        /* ボタンが潰れない */
      min-width: 72px;       /* お好みで 70〜90 */
    }
   
    .smallBtn:active{ transform: translateY(1px); }

    .lockNote{ margin-top: 8px; padding: 8px 10px; border: 1px dashed #ccc;
      border-radius: 10px; background: #fff; color:#666; font-size: 13px; }

    /* ===== Reorder (案A) ===== */
    .reorderbar{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    .modebtn.primary{
      background:#111; color:#fff; border-color:#111; }

    .modebtn.ghost{ background:#fff; color:#111; }

    .reorder-ctl{ display:flex; gap:6px; margin-top:8px; }

    .reorder-ctl button{
      flex:1; padding:6px 8px; border:1px solid #ddd; border-radius:10px;
      background:#f7f7f7; font-weight:800; cursor:pointer; }

    .reorder-ctl button:disabled{ opacity:.35; cursor:default; }

    /* ===== Drag reorder (pointer) ===== */
    .mini.dragging{ opacity: .65; transform: scale(0.75); z-index: 999;
      position: relative; }
    .mini{ -webkit-touch-callout: none; /* iOSの長押しメニュー抑制 */ }

    /* 並べ替えモード中：mini内の文字を「選択対象」にしない */
    .reorder-on .mini,
    .reorder-on .mini *{
      user-select: none !important;
      -webkit-user-select: none !important;
      -webkit-touch-callout: none !important; /* iOS長押しメニュー抑制 */
    }

    /* ただし ↑↓ ボタンは普通に操作できるようにする（念のため） */
    .reorder-on .mini .reorder-ctl,
    .reorder-on .mini .reorder-ctl *{
      pointer-events: auto !important;
    }


    .drop-hint{ outline: 2px dashed #aaa; outline-offset: 4px; }

    body.noselect, body.noselect *{ user-select: none !important;
      -webkit-user-select: none !important; }

    /* 指についてくる複製（ghost） */
    .drag-ghost{ position: fixed; left: 0; top: 0; z-index: 9999;
      pointer-events: none; transform: scale(0.92); opacity: .92; }

    /* 元の位置を保持する穴（placeholder） */
    .drag-placeholder{ border: 2px dashed #aaa; border-radius: 10px;
      background: rgba(0,0,0,0.03); }

    .dragging-grid{
      touch-action: pan-y;   /* これがAndroidで効く */
    }

    .dragging-grid.drag-active{
      touch-action: none;
    }

    /* ドラッグ中は “指が触っている要素(.mini)側” もスクロール禁止にする */
    .dragging-grid.drag-active .mini,
    .dragging-grid.drag-active .mini *{
      touch-action: none;
    }

    .dragging-body{
      /* touch-action: none;  ←消す */
      touch-action: pan-y;          /* 縦スクロールOK */
      overscroll-behavior: contain; /* 端での変な戻りを軽減（任意） */
      overflow-y: auto;             /* hidden をやめる */
      overflow-x: hidden;
    }


  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div class="reorderbar" id="reorderBar">
        <a class="modebtn" href="list.html">閲覧一覧へ</a>

        <!-- 並べ替え（案A） -->
        <button class="modebtn ghost" id="btnReorder" type="button">並べ替え</button>
        <button class="modebtn primary hidden" id="btnReorderSave" type="button">並べ替え保存</button>
        <button class="modebtn ghost hidden" id="btnReorderCancel" type="button">キャンセル</button>
      </div>

      <div class="status" id="status"></div>
    </div>


    <!-- ===== List View ===== -->
    <div id="viewList">
      <input id="q" class="search" placeholder="検索（id / title）" />
      <div class="hint">タップすると編集画面へ</div>
      <div style="height:10px"></div>
      <div class="grid" id="grid"></div>
    </div>

    <!-- ===== Edit View ===== -->
    <div id="viewEdit" class="hidden">
      <div class="card">
        <div class="info">
          <div class="row">
            <span class="label">ID:</span>

            <!-- 既存カード：表示 -->
            <span class="status" id="idBadge"></span>

            <!-- 新規カード：入力 -->
            <div class="idRow hidden" id="idRowNew">
              <input class="text" id="idEdit" placeholder="例：ise（英小文字）" />
              <button class="smallBtn" id="btnIdConfirm" type="button">ID確定</button>
            </div>

            <div class="lockNote hidden" id="lockNote">
              新規作成：まずIDを, 英数と"_"(アンダーバー)だけで作成。（確定後に編集が有効になる）
            </div>
          </div>

          <div class="row">
            <span class="label">タイトル:</span>
            <input class="text" id="titleEdit" placeholder="例：伊勢神宮正殿" />
          </div>

          <div class="row">
            <span class="label">年代:</span>
            <input class="text" id="yearEdit" placeholder="例：7世紀頃" />
          </div>

          <div class="row">
            <span class="label">様式:</span>
            <input class="text" id="styleEdit" placeholder="例：神明造" />
          </div>

          <div class="row">
            <span class="label">建築家:</span>
            <input class="text" id="architectEdit" placeholder="例：不明" />
          </div>

          <div class="row">
            <span class="label">場所:</span>
            <input class="text" id="locationEdit" placeholder="例：三重県" />
          </div>

          <div class="row"><span class="label">メモ:</span></div>
          <textarea class="memo" id="descEdit" placeholder="メモを編集"></textarea>
        </div>

        <!-- 画像1 -->
        <div class="image-block">
          <div class="image-head">画像1：</div>
          <input type="file" id="file1" accept="image/*">
          <div class="thumb"><img id="img1b" alt="画像1プレビュー"></div>
        </div>

        <!-- 画像2 -->
        <div class="image-block">
          <div class="image-head">画像2：</div>
          <input type="file" id="file2" accept="image/*">
          <div class="thumb"><img id="img2b" alt="画像2プレビュー"></div>
        </div>

        <div class="nav">
          <button class="navbtn" id="btnSave" type="button">保存</button>
          <button class="navbtn" id="btnDelete" type="button">削除</button>
          <button class="navbtn" id="btnBack" type="button">キャンセル</button>
        </div>

        <div class="hint" id="editHint"></div>
      </div>
    </div>
  </div>

<script>
  // ===== 固定設定 =====
  const COLLECTION = "kindai";
  const API_BASE   = "https://archicard-api.yuki-548.workers.dev";
  const API_ITEMS  = `${API_BASE}/api/items?collection=${encodeURIComponent(COLLECTION)}`;
  const API_ITEM   = `${API_BASE}/api/item`;
  const API_IMG    = `${API_BASE}/api/image`;
  const R2_PUBLIC_BASE = "https://pub-6e7134ff7595457297783250821603b8.r2.dev";

  // ===== Auto scroll during drag =====
  const AUTO_SCROLL_EDGE = 80;     // 上下何pxをスクロール領域にするか
  const AUTO_SCROLL_SPEED = 18;   // 1フレームあたりのスクロール量

  // ===== 状態 =====
  let items = [];
  let current = null;

  // 新規作成フラグと、ID確定フラグ（この2つだけにする）
  let isNew = false;
  let idConfirmed = false;
  
  // ===== Reorder mode (案A) =====
  let reorderMode = false;
  let reorderEls = []; // items[i] に対応する .mini DOM を保持

  // ===== Drag state (placeholder方式) =====
  let drag = { active:false, pointerId:null, src:null, ghost:null,       // 追従する複製
    ph:null, offsetX:0, offsetY:0, raf:0, lastX:0, lastY:0 };

  function autoScrollDuringDrag(clientY){
    if (!drag.active) return;

    const vh = window.innerHeight;

    if (clientY < AUTO_SCROLL_EDGE) {
      // 上端
      window.scrollBy(0, -AUTO_SCROLL_SPEED);
    } else if (clientY > vh - AUTO_SCROLL_EDGE) {
      // 下端
      window.scrollBy(0, AUTO_SCROLL_SPEED);
    }
  }

  function setReorderButtonsVisible(visible){
    // 編集画面では並べ替えUIを全部消す
    $("btnReorder").classList.toggle("hidden", !visible);
    $("btnReorderSave").classList.toggle("hidden", !visible);
    $("btnReorderCancel").classList.toggle("hidden", !visible);
  }

  function startDrag(mini, pointerId, x, y){
    console.log("hasCapture?", $("grid").hasPointerCapture(pointerId));
    const grid = $("grid");

    grid.classList.add("drag-active");   // ★追加：ドラッグ中だけスクロール殺す
    try { grid.setPointerCapture(pointerId); } catch (_) {} // ★追加：指を確実に捕まえる

    // ★追加：Androidのスクロールを確実に止める
    document.addEventListener("touchmove", _blockTouchMove, { passive:false, capture:true });

    drag.active = true;
    drag.pointerId = pointerId;
    drag.src = mini;

    const r = mini.getBoundingClientRect();
    drag.offsetX = x - r.left;
    drag.offsetY = y - r.top;

    // placeholder（srcの場所に置く）
    const ph = document.createElement("div");
    ph.className = "mini drag-placeholder";
    ph.style.width  = r.width + "px";
    ph.style.height = r.height + "px";
    drag.ph = ph;

    // ghost
    const ghost = mini.cloneNode(true);
    ghost.classList.add("drag-ghost");
    ghost.style.width  = r.width + "px";
    ghost.style.height = r.height + "px";
    drag.ghost = ghost;
    document.body.appendChild(ghost);

    // ★ここが重要：srcの位置にphを入れてから、srcはdisplay:noneにする
    grid.insertBefore(ph, mini);
    mini.style.display = "none";            // ← visibility:hidden ではなく display:none

    // スクロール/選択抑制（後述のAndroid対策にも効く）
    document.body.classList.add("noselect", "dragging-body");
    grid.classList.add("dragging-grid");    // touch-action切替用
    grid.classList.add("drag-active"); // ★追加

    // pointer capture（miniをdisplay:noneにする前に取るのが安全）
    // ※すでに display:none を先にやってしまうと capture が失敗することがある
    // → なので、insertBeforeの前後どっちでもOKだが display:none の前がより安全
    // mini.setPointerCapture(pointerId);  // miniがdisplay:noneだと不安定な端末あり
    grid.setPointerCapture(pointerId);      // ★gridにcaptureの方が安定

    moveGhost(x, y);
  }


  function moveGhost(clientX, clientY){
    if (!drag.ghost) return;
    const left = clientX - drag.offsetX;
    const top  = clientY - drag.offsetY;
    drag.ghost.style.transform = `translate(${left}px, ${top}px) scale(0.92)`;
  }

  // placeholderを「指の下の要素」の前/後へ移動
  function updatePlaceholder(clientX, clientY){
    const grid = $("grid");
    const el = document.elementFromPoint(clientX, clientY);
    const over = el ? el.closest(".mini") : null;

    if (!over) return;
    if (over === drag.ph) return;

    const r = over.getBoundingClientRect();

    // ★複数列向け：左右は“前”、右側は“後”寄りに
    const dx = clientX - (r.left + r.width * 0.5);
    const dy = clientY - (r.top  + r.height * 0.5);

    const after = (Math.abs(dx) > Math.abs(dy)) ? (dx > 0) : (dy > 0);

    if (after) grid.insertBefore(drag.ph, over.nextSibling);
    else       grid.insertBefore(drag.ph, over);
  }


  function endDrag(pointerId){
    clearPress();
    if (!drag.active) return;
    if (drag.pointerId !== pointerId) return;

    const grid = $("grid");

    // srcをplaceholder位置へ戻す
    if (drag.ph && drag.src){
      drag.src.style.display = "";          // ★戻す
      grid.insertBefore(drag.src, drag.ph);
    }

    if (drag.ph) drag.ph.remove();
    if (drag.ghost) drag.ghost.remove();

    document.body.classList.remove("noselect", "dragging-body");
    // 並べ替えモード中は "dragging-body / dragging-grid" を維持する
    if (!reorderMode) document.body.classList.remove("dragging-body");
    if (!reorderMode) grid.classList.remove("dragging-grid");

    try { $("grid").releasePointerCapture(pointerId); } catch(e){}

    // DOM順→items順を復元
    reorderEls = Array.from(grid.querySelectorAll(".mini"));
    const map = new Map(items.map(it => [it.id, it]));
    items = reorderEls.map(el => map.get(el.dataset.id)).filter(Boolean);
    document.removeEventListener("touchmove", _blockTouchMove, { passive:false, capture:true });


    refreshReorderButtons();

    drag.active = false;
    drag.pointerId = null;
    drag.src = null;
    drag.ghost = null;
    drag.ph = null;
    if (drag.raf) cancelAnimationFrame(drag.raf);
    drag.raf = 0;

    grid.classList.remove("drag-active");
    try { $("grid").releasePointerCapture(pointerId); } catch (_) {}
  }

  // ★ 追加：ドラッグ中だけスクロール抑止するためのフック
  function _blockTouchMove(e){
    if (!drag || !drag.active) return;
    // cancelableじゃない場合は止められないが、止められる時は止める
    if (e.cancelable) e.preventDefault();
  }

  let reorderBackup = null; // 並べ替え開始時の items を保持

  // ===== Long-press config =====
  const LONGPRESS_MS = 500;   // 0.5秒
  const CANCEL_PX = 32;        // これ以上動いたら長押しキャンセル（スクロール優先）

  let press = { timer: null, pointerId: null, startX: 0,
    startY: 0, mini: null };

  function clearPress(){
    if (press.timer){
      clearTimeout(press.timer);
      press.timer = null;
    }

  // ★追加：capture解除
    try{
      if (press.pointerId != null) $("grid").releasePointerCapture(press.pointerId);
    }catch(e){}

    press.pointerId = null;
    press.mini = null;
  }


  function setReorderUI(on){
    reorderMode = !!on;
    // ★追加：並べ替え中だけCSSを効かせる
    document.body.classList.toggle("reorder-on", reorderMode);

    const grid = $("grid");

    // ★追加：Android対策。pointerdown前にtouch-actionを固定しておく
    grid.classList.toggle("dragging-grid", reorderMode);

    // ついでに、並べ替え中はページスクロールも抑止したいなら
    document.body.classList.toggle("dragging-body", reorderMode);

    // ボタン表示
    $("btnReorder").classList.toggle("hidden", reorderMode);
    $("btnReorderSave").classList.toggle("hidden", !reorderMode);
    $("btnReorderCancel").classList.toggle("hidden", !reorderMode);

    // 並べ替え中は検索欄そのものを隠す
    $("q").classList.toggle("hidden", reorderMode);

    // 念のため disabled も同期（保険）
    $("q").disabled = reorderMode;

    // 並べ替え中はステータスを少し出す
    if (reorderMode) setStatus("並べ替えモード：↑↓で順序を変えて、保存してください");
    if (!reorderMode){ reorderEls = [];}

  }

  function renumberSort(step=1000){
    for (let i = 0; i < items.length; i++){
      items[i].sort = (i + 1) * step;
    }
  }

  async function putItem(it){
    // /api/item は「全項目PUT」前提なので、既存save()と同じ形で送る
    const payload = {
      collection: COLLECTION,
      id: it.id,
      title: it.title ?? "",
      year: it.year ?? "",
      style: it.style ?? "",
      architect: it.architect ?? "",
      location: it.location ?? "",
      desc: it.desc ?? "",
      images_json: (Array.isArray(it.images) && it.images.length >= 2)
        ? it.images
        : buildImagesJson(COLLECTION, it.id),
      sort: (it.sort ?? null)
    };

    const res = await fetch(API_ITEM, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!res.ok){
      throw new Error(`PUT failed HTTP ${res.status} (${it.id})`);
    }
  }

  async function saveReorder(){
    // まずローカルで1000刻みに再採番
    renumberSort(1000);

    setStatus("並べ替え保存中…");

    // 全件PUT（案Aの最小実装：堅牢）
    // カードが増えて重くなったら「差分だけPUT」に拡張できる
    for (let i = 0; i < items.length; i++){
      setStatus(`並べ替え保存中… (${i+1}/${items.length})`);
      await putItem(items[i]);
    }

    setStatus("並べ替え保存OK", "ok");
    setReorderUI(false);

    // 念のため再読込（DBの並びを確実に反映）
    await load();
  }



  // ===== util =====
  function $(id){ return document.getElementById(id); }

  function setStatus(msg, cls=""){
    const el = $("status");
    el.className = "status " + cls;
    el.textContent = msg;
  }

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function bust(url){
    if (!url) return "";
    const sep = url.includes("?") ? "&" : "?";
    return url + sep + "v=" + Date.now();
  }

  function setPreview(imgEl, url){
    if (!imgEl) return;

    // 404で隠れてても、更新時は必ず復帰させる
    imgEl.style.display = "";
    imgEl.onerror = () => { imgEl.style.display = "none"; };

    // キャッシュ対策：必ず bust を通す
    imgEl.src = bust(url);
  }

  function clearPreview(imgEl){
    if (!imgEl) return;
    imgEl.onerror = null;
    imgEl.src = "";
    imgEl.style.display = "none"; // 新規では「何もない」を明示
  }

  // webp固定：常に2枚のURLを生成（空でも入る）
  function buildImagesJson(collection, id){
    const c = encodeURIComponent(collection);
    const i = encodeURIComponent(id);
    return [
      `${R2_PUBLIC_BASE}/${c}/${i}/1.webp`,
      `${R2_PUBLIC_BASE}/${c}/${i}/2.webp`,
    ];
  }

  function normalizeId(raw){
    const id = (raw ?? "").trim();
    // 英小文字/数字/ハイフン/アンダースコア（必要なら調整）
    if (!id) return { ok:false, id:"", reason:"IDが空です" };
    if (!/^[a-z0-9_-]+$/.test(id)) return { ok:false, id, reason:"IDは英小文字・数字・_・- のみ" };
    return { ok:true, id, reason:"" };
  }

  function computeNextSort(){
    let mx = 0;
    for (const it of items){
      const s = Number(it.sort);
      if (Number.isFinite(s) && s > mx) mx = s;
    }
    return mx + 1000;
  }

  function setEditEnabled(enabled){
    // ID確定前はここ全部OFF
    const ids = ["titleEdit","yearEdit","styleEdit","architectEdit","locationEdit","descEdit",
                 "file1","file2","btnSave"];
    for (const k of ids){
      const el = $(k);
      if (!el) continue;
      el.disabled = !enabled;
    }

    // 画像は未アップロードでもURLが入るので、プレビューは確定後に表示
    $("editHint").textContent = enabled
      ? "画像が未アップロードでも  URL を生成する（webp固定）"
      : "ID確定後に編集・画像アップロードができる";
  }

  function showList(){
    $("viewList").classList.remove("hidden");
    $("viewEdit").classList.add("hidden");

    // ★追加：一覧では並べ替えボタンを戻す
    $("reorderBar").classList.remove("hidden");

    current = null;

    const u = new URL(location.href);
    u.search = ""; // ★全部消す
    history.replaceState(null, "", u.toString());
  }




  function renderGrid(){
    const grid = $("grid");

    if (reorderMode){
      // 並べ替えモードは「初回だけ」DOMを構築
      if (reorderEls.length === items.length && grid.children.length === items.length){
        // すでに構築済みなら、ボタン状態だけ整える
        refreshReorderButtons();
        return;
      }

      grid.innerHTML = "";
      reorderEls = [];

      for (let idx = 0; idx < items.length; idx++){
        const it = items[idx];
        const div = document.createElement("div");
        div.className = "mini";
        div.dataset.draggable = "1";      // ←追加：目印
        div.dataset.id = it.id;  // ★これを追加（並び替え結果をitemsへ確実に反映する鍵）

        div.dataset.idx = String(idx);

        const img = it.images?.[0] ?? "";
        div.innerHTML = `
          ${img ? `<img class="thumbimg" src="${escapeHtml(img)}" alt="" loading="lazy"
          onerror="if(!this.dataset.retry){this.dataset.retry=1;setTimeout(()=>this.src=this.src,300);}else{this.style.display='none'}">` : ""}
          
          <div class="miniTitle">${escapeHtml(it.title)} <span style="color:#999;font-weight:700">(${escapeHtml(it.id)})</span></div>
          
          <!--
          <div class="reorder-ctl">
            <button type="button" data-act="up">↑</button>
            <button type="button" data-act="down">↓</button>
          </div>
          -->
        `;

        // クリックはイベント委譲にする（後述）。ここでは何もしない
        grid.appendChild(div);
        reorderEls.push(div);
      }

      refreshReorderButtons();
      return;
    }

    // ===== 通常表示（既存ロジック） =====
    grid.innerHTML = "";
    const q = $("q").value.trim().toLowerCase();

    const filtered = items.filter(it => {
      if (!q) return true;
      return (it.id||"").toLowerCase().includes(q) || (it.title||"").toLowerCase().includes(q);
    });

    const add = document.createElement("div");
    add.className = "mini";
    add.innerHTML = `<div class="add-card">＋ 新規</div>`;
    add.addEventListener("click", () => openNew());
    grid.appendChild(add);

    for (const it of filtered){
      const div = document.createElement("div");
      div.className = "mini";
      const img = it.images?.[0] ?? "";
      div.innerHTML = `
        ${img ? `<img class="thumbimg" src="${escapeHtml(img)}" alt="" loading="lazy"
        onerror="if(!this.dataset.retry){this.dataset.retry=1;setTimeout(()=>this.src=this.src,300);}else{this.style.display='none'}">` : ""}
        <div class="miniTitle">${escapeHtml(it.title)} <span style="color:#999;font-weight:700">(${escapeHtml(it.id)})</span></div>
      `;
      div.addEventListener("click", () => openEdit(it));
      grid.appendChild(div);
    }

    if (filtered.length === 0){
      const p = document.createElement("div");
      p.className = "hint";
      p.textContent = "該当なし";
      grid.appendChild(p);
    }
  }





  function refreshReorderButtons(){
    // 先頭と末尾だけdisable、他はenable
    for (let i = 0; i < reorderEls.length; i++){
      const el = reorderEls[i];
      el.dataset.idx = String(i);

      const up = el.querySelector('button[data-act="up"]');
      const dn = el.querySelector('button[data-act="down"]');

      if (up) up.disabled = (i === 0);
      if (dn) dn.disabled = (i === reorderEls.length - 1);
    }
  }


 function moveItemNoRender(fromIndex, toIndex){
    if (toIndex < 0 || toIndex >= items.length) return;

    const grid = $("grid");
    const elFrom = reorderEls[fromIndex];
    const elTo   = reorderEls[toIndex];
    if (!elFrom || !elTo) return;

    // 1) DOMを先に動かす（配列をいじる前の参照で確実に移動）
    if (fromIndex < toIndex){
      // 下へ：目的要素 elTo の「次」に入れる
      grid.insertBefore(elFrom, elTo.nextSibling);
    } else if (fromIndex > toIndex){
      // 上へ：目的要素 elTo の「前」に入れる
      grid.insertBefore(elFrom, elTo);
    } else {
      return;
    }

    // 2) 配列(items, reorderEls)を同じ移動で更新
    const [movedItem] = items.splice(fromIndex, 1);
    items.splice(toIndex, 0, movedItem);

    const [movedEl] = reorderEls.splice(fromIndex, 1);
    reorderEls.splice(toIndex, 0, movedEl);

    // 3) idx / disabled を更新
    refreshReorderButtons();
  }

  // ===== 画面遷移 =====
  function openNew(){
    // ★追加：編集では上のバーを消す
    $("reorderBar").classList.add("hidden");

    // ★追加：編集中に並べ替えが残ってたら終わらせる
    if (reorderMode) setReorderUI(false);

    isNew = true;
    idConfirmed = false;

    // ★ 新規用ID UIを必ず表示
    $("idRowNew").style.display = "flex";
    $("lockNote").style.display = "block";

    $("idBadge").style.display = "none";
    $("idEdit").disabled = false;


    current = {
      id: "",
      sort: null,
      title:"",
      year:"",
      style:"",
      architect:"",
      location:"",
      desc:"",
      images: [] // ID確定時に必ず2枚URLで埋める
    };

    $("viewList").classList.add("hidden");
    $("viewEdit").classList.remove("hidden");

    // 新規：ID入力UI
    $("idBadge").classList.add("hidden");
    $("idRowNew").classList.remove("hidden");
    $("lockNote").classList.remove("hidden");

    $("idEdit").value = "";
    $("titleEdit").value = "";
    $("yearEdit").value = "";
    $("styleEdit").value = "";
    $("architectEdit").value = "";
    $("locationEdit").value = "";
    $("descEdit").value = "";

    clearPreview($("img1b"));
    clearPreview($("img2b"));

    $("idEdit").disabled = false;

    // ID確定までロック
    setEditEnabled(false);

    // 削除は無効（保存前）
    $("btnDelete").disabled = true;

    const u = new URL(location.href);
    u.searchParams.delete("id");
    u.searchParams.set("mode", "new");
    history.replaceState(null, "", u.toString());

    setStatus("新規作成：IDを確定してください", "");
  }

  function openEdit(it){
    // ★追加：編集では上のバーを消す
    $("reorderBar").classList.add("hidden");

    // ★追加：編集中に並べ替えが残ってたら終わらせる
    if (reorderMode) setReorderUI(false);

    isNew = false;
    idConfirmed = true;

    // ★ 新規用ID入力UIを完全に消す
    $("idRowNew").style.display = "none";
    $("lockNote").style.display = "none";

    // ★ ID表示バッジだけ出す
    $("idBadge").style.display = "inline";
    $("idBadge").textContent = it.id;

    // 保険：input が存在しても操作不能
    $("idEdit").disabled = true;

    current = it;
    current._fixedId = it.id;

    // images が空なら、webp固定で補完（要件どおり）
    if (!Array.isArray(current.images) || current.images.length < 2){
      current.images = buildImagesJson(COLLECTION, current.id);
    }

    $("viewList").classList.add("hidden");
    $("viewEdit").classList.remove("hidden");

    $("titleEdit").value = it.title ?? "";
    $("yearEdit").value = it.year ?? "";
    $("styleEdit").value = it.style ?? "";
    $("architectEdit").value = it.architect ?? "";
    $("locationEdit").value = it.location ?? "";
    $("descEdit").value = it.desc ?? "";

    // 既存は生成URLをそのまま表示（実体がないなら onerror で消える）
    setPreview($("img1b"), current.images[0]);
    setPreview($("img2b"), current.images[1]);

    $("img1b").onerror = () => { $("img1b").style.display = "none"; };
    $("img2b").onerror = () => { $("img2b").style.display = "none"; };
    $("img1b").style.display = "";
    $("img2b").style.display = "";

    // 編集可能
    setEditEnabled(true);

    // 削除OK
    $("btnDelete").disabled = false;

    const u = new URL(location.href);
    u.searchParams.set("id", it.id);
    u.searchParams.delete("mode");
    history.replaceState(null, "", u.toString());

    setStatus(`編集中：${it.id}`, "ok");

    // ★ 既存カードではID入力UIを物理的に潰す
    $("idRowNew").classList.add("hidden");
    $("lockNote").classList.add("hidden");
    $("idBadge").classList.remove("hidden");

    // 保険：入力欄が存在しても操作不能に
    $("idEdit").disabled = true;
    $("idEdit").value = current.id;
  }

  function goBack(){
    // 新規でID未確定ならそのまま一覧へ
    if (isNew && !idConfirmed) {
      showList();
      return;
    }
    // それ以外は一覧へ
    showList();
  }

  // ===== ID確定 =====
  function confirmId(){
    if (!current) return;

    const n = normalizeId($("idEdit").value);
    if (!n.ok){
      setStatus(n.reason, "err");
      return;
    }

    // 既に同じIDが存在したら止める（上書き事故防止）
    const exists = items.some(x => x.id === n.id);
    if (exists){
      setStatus("そのIDは既に存在します（別のIDにしてください）", "err");
      return;
    }

    current.id = n.id;
    idConfirmed = true;

    // images_json を必ず生成（空でもURLが入る）
    current.images = buildImagesJson(COLLECTION, current.id);

    // UI切替：入力→表示
    $("idRowNew").classList.add("hidden");
    $("lockNote").classList.add("hidden");
    $("idBadge").classList.remove("hidden");
    $("idBadge").textContent = current.id;

    // プレビューは生成URLを表示（実体が無ければ onerror で非表示）
    $("img1b").style.display = "";
    $("img2b").style.display = "";
    setPreview($("img1b"), current.images[0]);
    setPreview($("img2b"), current.images[1]);
    $("img1b").onerror = () => { $("img1b").style.display = "none"; };
    $("img2b").onerror = () => { $("img2b").style.display = "none"; };

    // 編集/アップロード解禁
    setEditEnabled(true);

    // URL更新
    const u = new URL(location.href);
    u.searchParams.set("id", current.id);
    u.searchParams.delete("mode");
    history.replaceState(null, "", u.toString());

    setStatus(`ID確定：${current.id}`, "ok");
  }

  // ===== 画像圧縮（webp固定） =====
  async function compressToUnderBytes(file, {
    maxBytes = 400 * 1024,
    maxDim = 2200,
    minDim = 900,
    type = "image/webp",
  } = {}) {
    let bitmap;
    try {
      bitmap = await createImageBitmap(file);
    } catch {
      throw new Error("この画像形式はブラウザで圧縮できません（HEIC等の可能性）。JPEG/PNGに変換してから試してください。");
    }

    const w0 = bitmap.width, h0 = bitmap.height;
    let scale = 1.0;
    const maxSide = Math.max(w0, h0);
    if (maxSide > maxDim) scale = maxDim / maxSide;

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    async function encode(q, sc) {
      const w = Math.max(1, Math.floor(w0 * sc));
      const h = Math.max(1, Math.floor(h0 * sc));
      canvas.width = w; canvas.height = h;
      ctx.clearRect(0, 0, w, h);
      ctx.drawImage(bitmap, 0, 0, w, h);
      const blob = await new Promise((resolve) => canvas.toBlob(resolve, type, q));
      return blob;
    }

    const qualities = [0.86, 0.78, 0.70, 0.62, 0.54, 0.46, 0.38, 0.32, 0.28];
    for (const q of qualities) {
      const blob = await encode(q, scale);
      if (blob && blob.size <= maxBytes) return blob;
    }

    let sc = scale;
    while (true) {
      const w = Math.floor(w0 * sc), h = Math.floor(h0 * sc);
      if (Math.max(w, h) <= minDim) break;

      sc *= 0.85;
      const blob = await encode(0.35, sc);
      if (blob && blob.size <= maxBytes) return blob;
    }

    const lastScale = Math.max(minDim / maxSide, 0.1);
    const last = await encode(0.28, lastScale);
    if (!last) throw new Error("圧縮に失敗しました");
    return last;
  }

  // ===== 画像アップロード =====
  async function uploadSlot(slot){
    if (!current) return;
    if (!idConfirmed || !current.id){
      setStatus("先にIDを確定してください", "err");
      return;
    }

    const fileEl = slot === 1 ? $("file1") : $("file2");
    const file = fileEl.files?.[0];
    if (!file){
      setStatus(`画像${slot}を選択してください`, "err");
      return;
    }

    setStatus(`画像${slot} 圧縮中…`);
    let blob;
    try {
      blob = await compressToUnderBytes(file, { maxBytes: 400 * 1024, type: "image/webp" });
    } catch (e) {
      setStatus(e.message || "圧縮失敗", "err");
      return;
    }

    setStatus(`画像${slot} アップロード中… (${Math.round(blob.size/1024)}KB)`);

    const upUrl =
      `${API_IMG}?collection=${encodeURIComponent(COLLECTION)}&id=${encodeURIComponent(current.id)}&slot=${slot}`;

    const res = await fetch(upUrl, {
      method: "PUT",
      headers: { "Content-Type": "image/webp" },
      body: blob
    });

    if (!res.ok){
      const txt = await res.text().catch(() => "");
      setStatus(`画像アップロード失敗 HTTP ${res.status}${txt}`, "err");
      return;
    }

    // UI側は生成URLを保持する（要件）
    // ただしレスポンスURLが返ったら同じはずなので、そこを使ってもOK
    let data = null;
    try { data = await res.json(); } catch {}
    const urlOut = data?.url || current.images?.[slot - 1];

    if (!Array.isArray(current.images) || current.images.length < 2){
      current.images = buildImagesJson(COLLECTION, current.id);
    }
    current.images[slot - 1] = urlOut;

    if (slot === 1) {
      setPreview($("img1b"), urlOut);
      $("file1").value = "";
    } else {
      setPreview($("img2b"), urlOut);
      $("file2").value = "";
    }

    setStatus(`画像${slot} OK`, "ok");
    renderGrid();
  }

  // ===== 保存 =====
  async function save(){
    if (!current) return;

    if (isNew && !idConfirmed){
      setStatus("新規作成：先にIDを確定してください", "err");
      return;
    }

    // 念のため images を必ず生成（要件）
    if (!Array.isArray(current.images) || current.images.length < 2){
      current.images = buildImagesJson(COLLECTION, current.id);
    }

    const fixedId = isNew ? current.id : (current._fixedId ?? current.id);
    const payload = {
      collection: COLLECTION,
      id: fixedId,
      title: $("titleEdit").value ?? "",
      year: $("yearEdit").value ?? "",
      style: $("styleEdit").value ?? "",
      architect: $("architectEdit").value ?? "",
      location: $("locationEdit").value ?? "",
      desc: $("descEdit").value ?? "",
      images_json: current.images, // ←必ずURL2本入る
      sort: (current.sort ?? null)
    };

    // 新規は末尾へ
    if (payload.sort == null) payload.sort = computeNextSort();

    setStatus("保存中…");
    const res = await fetch(API_ITEM, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    if (!res.ok){
      setStatus(`保存失敗 HTTP ${res.status}`, "err");
      return;
    }

    // ローカル反映
    if (isNew){
      const newItem = {
        id: payload.id,
        sort: payload.sort,
        title: payload.title,
        year: payload.year,
        style: payload.style,
        architect: payload.architect,
        location: payload.location,
        desc: payload.desc,
        images: payload.images_json
      };
      items.push(newItem);
      items.sort((a,b) => (a.sort??0) - (b.sort??0) || (a.id||"").localeCompare(b.id||""));
      current = newItem;
      isNew = false;
    } else {
      current.title = payload.title;
      current.year = payload.year;
      current.style = payload.style;
      current.architect = payload.architect;
      current.location = payload.location;
      current.desc = payload.desc;
      current.images = payload.images_json;
      current.sort = payload.sort;
    }

    setStatus("保存OK", "ok");
    renderGrid();
    showList();
  }

  // ===== 削除 =====
  async function delCurrent(){
    if (!current || isNew){
      setStatus("新規カードは削除できません（保存前）", "err");
      return;
    }

    const ok = confirm(`「${current.id}」を削除します。よろしいですか？`);
    if (!ok) return;

    setStatus("削除中…");
    const url = `${API_ITEM}?collection=${encodeURIComponent(COLLECTION)}&id=${encodeURIComponent(current.id)}`;
    const res = await fetch(url, { method: "DELETE" });

    if (!res.ok){
      setStatus(`削除失敗 HTTP ${res.status}`, "err");
      return;
    }

    items = items.filter(x => x.id !== current.id);
    current = null;

    setStatus("削除OK", "ok");
    renderGrid();
    showList();
  }

  // ===== 初期ロード =====
  async function load(){
    setStatus("読み込み中…");
    const res = await fetch(API_ITEMS, { cache: "no-store" });
    if (!res.ok){
      setStatus(`読み込み失敗 HTTP ${res.status}`, "err");
      return;
    }
    items = await res.json();
    if (!Array.isArray(items)) items = [];

    // 既存でも images が空なら webp固定で補完（要件）
    for (const it of items){
      if (!Array.isArray(it.images) || it.images.length < 2){
        it.images = buildImagesJson(COLLECTION, it.id);
      }
    }

    setStatus(`読み込みOK：${items.length}件`, "ok");
    renderGrid();

    const params = new URLSearchParams(location.search);
    const startId = params.get("id");
    const mode = params.get("mode");

    if (startId) {
      const it = items.find(x => x.id === startId);
      if (it) {
        openEdit(it);   // ★ id があれば絶対にここ
      } else {
        showList();
      }
    } else {
      showList();       // ★ id が無いときだけ new / list を考える
    }

  }

  // ===== events =====
  $("q").addEventListener("input", renderGrid);
  $("btnBack").addEventListener("click", goBack);
  $("btnSave").addEventListener("click", save);
  $("btnDelete").addEventListener("click", delCurrent);
  $("btnIdConfirm").addEventListener("click", confirmId);

  // Enterでも確定
  $("idEdit").addEventListener("keydown", (e) => {
    if (e.key === "Enter") confirmId();
  });



  // ===== reorder events =====

  // ===== ↑↓ボタン（並べ替えモード用） =====
  /*
  $("grid").addEventListener("click", (e) => {
    if (!reorderMode) return;

    const btn = e.target.closest("button[data-act]");
    if (!btn) return;

    const mini = e.target.closest(".mini");
    if (!mini) return;

    const idx = Number(mini.dataset.idx);
    if (!Number.isFinite(idx)) return;

    const act = btn.dataset.act;
    e.stopPropagation();

    if (act === "up")   moveItemNoRender(idx, idx - 1);
    if (act === "down") moveItemNoRender(idx, idx + 1);
  });
  */

  $("btnReorder").addEventListener("click", () => {
    reorderBackup = items.slice();   // ★参照の浅いコピーでOK（並びだけ戻したい）
    setReorderUI(true);
    renderGrid();
  });

  $("btnReorderCancel").addEventListener("click", () => {

    // ★ドラッグ中なら確実に終わらせてDOM/状態をクリーンにする
    if (drag && drag.active) endDrag(drag.pointerId);
    // ★items の並びを元に戻す
    if (reorderBackup) items = reorderBackup.slice();
    reorderBackup = null;

    setReorderUI(false);
    renderGrid();
  });

  $("btnReorderSave").addEventListener("click", () => {
    saveReorder().catch(e => {
      console.error(e);
      setStatus("並べ替え保存エラー：console を確認", "err");
    });
  });



  $("grid").addEventListener("pointerdown", (e) => {
    if (!reorderMode) return;

    // ↑↓ボタンはドラッグ開始しない（クリックで動かす）
    if (e.target.closest("button[data-act]")) return;

    const mini = e.target.closest(".mini");
    if (!mini) return;

    // ↑↓ボタンは除外
    if (e.target.closest("button[data-act]")) return;


    clearPress();
    press.pointerId = e.pointerId;
    press.startX = e.clientX;
    press.startY = e.clientY;
    press.mini = mini;

    press.timer = setTimeout(() => {
      // 長押し成立
      if (!reorderMode) return;
      if (drag.active) return;
      if (press.pointerId !== e.pointerId) return;
      if (!press.mini) return;

      setStatus("長押し成立：ドラッグ開始", "ok");
      startDrag(press.mini, e.pointerId, press.startX, press.startY);
      
    }, LONGPRESS_MS);
  });

  $("grid").addEventListener("pointermove", (e) => {
        
    // 長押し待ち中：大きく動いたらキャンセル（スクロール優先）
    if (!drag.active && press.timer && press.pointerId === e.pointerId){
      const dx = e.clientX - press.startX;
      const dy = e.clientY - press.startY;
      if ((dx*dx + dy*dy) > (CANCEL_PX*CANCEL_PX)){
        clearPress();
        return;
      }
    }

           if (drag.active){
      if (drag.pointerId !== e.pointerId) return;
      e.preventDefault();

      drag.lastX = e.clientX;
      drag.lastY = e.clientY;

      // ★ 追加：オートスクロール
      autoScrollDuringDrag(e.clientY);

      if (!drag.raf){
        drag.raf = requestAnimationFrame(() => {
          drag.raf = 0;
          moveGhost(drag.lastX, drag.lastY);
          updatePlaceholder(drag.lastX, drag.lastY);
        });
      }
      return;
    }
  },{ passive: false });


  $("grid").addEventListener("pointerup", (e) => {
    if (!reorderMode) return;
    if (drag.active) endDrag(e.pointerId);
    clearPress(); // 長押し待ちも止める
  });

  $("grid").addEventListener("pointercancel", (e) => {
    if (!reorderMode) return;
    if (drag.active) endDrag(e.pointerId);
    clearPress(); // 長押し待ちも止める
  });

  $("grid").addEventListener("contextmenu", (e) => {
    if (reorderMode) e.preventDefault();
  }); 


  // ファイル変更 → 即アップロード（ID確定後のみ）
  $("file1").addEventListener("change", () => uploadSlot(1));
  $("file2").addEventListener("change", () => uploadSlot(2));

  load().catch(e => {
    console.error(e);
    setStatus("エラー：console を確認", "err");
  });
</script>
</body>
</html>
